% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/monotoneQP.R
\name{monotoneQP}
\alias{monotoneQP}
\title{R Wrapper for Custom QP Solver for Nearest Empirical Quantile Function in Frobenius Norm}
\usage{
monotoneQP(Y, C_init = NULL, lower = -Inf, upper = Inf, eps = 1e-10)
}
\arguments{
\item{Y}{An (\code{m})-long numeric vector (or (\code{n} \eqn{\times} \code{m}) matrix) with no missing, all finite entries.}

\item{C_init}{An optional (\code{m + 1})-long numeric vector (or (\code{n} \eqn{\times} \code{m + 1}) matrix) of non-negative entries, specifying initial active set(s) for optimization. Active sets are identified by positive entries, row-wise if a matrix.}

\item{lower}{An optional numeric scalar (default \code{-Inf}) lower box constraint; must be strictly less than \code{upper}.}

\item{upper}{An optional numeric scalar (default \code{Inf}) upper box constraint; must be strictly greater than \code{lower}.}

\item{eps}{tolerance level (default \code{1e-10}).}
}
\value{
A list object with components:
\tabular{ll}{
\code{Lagrange_Multiplier} \tab returns a (\code{n} \eqn{\times} (\code{m + 1})) matrix, row-wise contains the Lagrange multipliers associated with the QP problems. \cr
\code{Solution} \tab returns a (\code{n} \eqn{\times} \code{m}) matrix, row-wise contains the solutions to the QP problems. \cr
}
}
\description{
\code{monotoneQP()} wraps an \link{Rcpp} implementation of a custom active set method for
solving a specific quadratic programming (QP) problem, of finding the nearest
vector in Frobenius norm to an input vector, with the constraints that the
output vector should be monotone non-decreasing across its entries,
and obey user-specified box constraints. The function permits a matrix input,
where this QP problem is solved row-wise, and also permits warm starts, in
the form of specifying an initial active-constraint matrix. Implementation
is based on the dual-active set method of
\insertCite{arnstrom_dual_2022}{fastfrechet}, taking advantage of
simplifications in this setting which avoid \eqn{LDL^{\top}} decompositions
and other costly matrix product operations.
}
\examples{
# Set box constraints:
lower = 0.5
upper = 1.5

# Generate example vector:
m = 100
set.seed(31)
y = rnorm(m, 2 * seq(0, 1, len = m), 0.1)

# Calculate monotone, box-constrained projection:
output = fastfrechet::monotoneQP(y, lower = 0.5, upper = 1.5)

# Note: to numerical precision, these QFs are non-decreasing...
min(diff(output$Solution[1, ]))

# ...bounded from below by the lower bound...
min(output$Solution) - lower

# ...and bounded from above by the upper bound...
max(output$Solution) - upper

# Plot values of the generated vector:
plot(y, main = "Monotone and Box Constrained", las = 1,
     xlab = "Vector Entry", ylab = expression("y, "*hat("q")))
abline(h = c(lower, upper), lty = 2, col = "gray80")

# Add values of monotone projection:
points(output$Solution[1, ], pch = 20)

legend("topleft", pch = c(1, 20), bty = "n",
       legend = c("Unconstrained", "Monotone Constrained"))
}
\references{
\insertRef{arnstrom_dual_2022}{fastfrechet}
}
